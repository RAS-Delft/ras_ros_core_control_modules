#!/usr/bin/env python3

import time
import numpy as np
from std_msgs.msg import Float32MultiArray

"""
The following two functions give the relation between the thruster use and the force generated by the thruster of various types. 
The red thrusters are weaker than the black ones, hence the different relation. The relation of the red ship is currently unkown exactly, thus the 0.8 factor is a guess.
Aft thrusters have a second order polynomial relation here, as it is easily inverted to get the inverse relations. The bow thruster has a linear relation.
The aft thruster relationship is mirrorded in the negative direction, assuming it behaves similarly in backwards direction.

The relation of the black aft thrusters is based on a 2nd order polynomial fit of the data from technical report:
"Tito Neri model scale vessel thruster behaviour" March 17, 2022 - RAS Delft

A sidenote if anyone is interested in the data that resulted in the polynomial fit:
The dataset upon the curve is fitted is:
rps		force[N]
-----------------
17.0000	0.3254
25.0000	0.7080
27.0000	0.6981
28.0000	0.6883
	0	0.0899
28.0000	0.8257
12.0000	0.1095
	0	0.0409
32.0000	1.0611
37.0000	1.4829
25.0000	0.6000
39.0000	1.5320
34.0000	1.2867
	0	0.0605
22.0000	0.4529
26.0000	0.6099
	0	0.0213
31.0000	0.8453
21.0000	0.4038
38.0000	1.4535
7.0000	0.0114
39.0000	1.3358
27.0000	0.6883
33.0000	0.9924
8.0000   -0.0082
18.0000	0.2076
16.0000	0.1095
	0   -0.1063
	0   -0.1063
24.0000	0.3940
"""
def TN_thrusterusage_to_force1(thrustertype:str):
	"""
	Gives the relation between the thruster use and the force generated
	The user is responsible of taking into account the limits of the thruster
	Aft_thrusters: quadratic relation
	Bow_thruster: linear relation
	"""

	"""
	Rough measurements of the black and red thrusters compared done by bartboogmans 
	at june 2023 showed that the red thrusters have a similarly shaped relation as the black thrusters,
	but with a factor of 0.6584. This factor is used to scale the red thruster relation to the black 
	thrust relation. This factor is not exact, but sufficient for now.
	"""
	factor_red_thruster = 0.6584

	if thrustertype == "aft_black":
		return lambda v: (0.0009752*v*v)*np.sign(v)
	elif thrustertype == "aft_red":
		return lambda v: (0.0009752*v*v*factor_red_thruster)*np.sign(v)
	elif thrustertype == "bowThruster":
		return lambda PWM_value: PWM_value*3.575

def TN_force_to_thrusterusage1(thrustertype:str):
	"""
	Gives the relation between the force generated and the thruster use
	The user is responsible of taking into account the limits of the thruster
	Aft_thrusters: quadratic relation
	Bow_thruster: linear relation
	"""

	"""
	Rough measurements of the black and red thrusters compared done by bartboogmans 
	at june 2023 showed that the red thrusters have a similarly shaped relation as the black thrusters,
	but with a factor of 0.6584. This factor is used to scale the red thruster relation to the black 
	thrust relation. This factor is not exact, but sufficient for now.
	"""
	factor_red_thruster = 0.6584

	if thrustertype == "aft_black":
		return lambda f: np.sqrt(np.abs(f)/(0.0009752))*np.sign(f)
	elif thrustertype == "aft_red":
		return lambda f: np.sqrt(np.abs(f)/(0.0009752*factor_red_thruster))*np.sign(f)
	elif thrustertype == "bowThruster":
		return lambda f: f/3.575

def TN_thrusterusage_to_force2(thrustertype:str):
	"""
	This function is the old relationship of a third order polynomial fit.
	Evenly numbered orders are not considered to make the fit represent backwards motion as well, as it will be symmetric.
	Unfortunately this third order fit is not so easily inverted, hence the new relation above.
	Aft_thrusters: ax^3+bx relation (no quadratic term)
	Bow_thruster: linear relation
	"""
	if thrustertype == "aft_black":
		return lambda v: ((1.925e-5)*v*v*v+(1.061e-2)*v)
	elif thrustertype == "aft_red":
		return lambda v: ((1.925e-5)*v*v*v+(1.061e-2)*v)
	elif thrustertype == "bowThruster":
		return lambda PWM_value: PWM_value*3.575

def generate_rosmsg_PID_status(pid):
	""" generates a float32MultiArray ros message with the current PID status """
	msg = Float32MultiArray()
	# [reference, error, output (last_y), proportional output (last_yp), integral output (last_yi), derivative output (last_yd), timestep (dt), integral buildup (error_integral), state]
	msg.data = [pid.ref, pid.last_error, pid.last_y, pid.last_yp, pid.last_yi, pid.last_yd, pid.last_dt, pid.error_integral, pid.state]
	return msg

class PIDController():
	"""
	A real-time PID controller featuring integral buildup limiting, output bounding
	"""
	def __init__(self,Kp:float,Ki:float,Kd:float,**kwargs):
		self.kp = Kp
		self.ki = Ki
		self.kd = Kd

		# Set kwargs
		self.integral_limits = kwargs['integral_limits'] if 'integral_limits' in kwargs else []
		self.output_limits = kwargs['output_limits'] if 'output_limits' in kwargs else []
		self.ref = kwargs['ref_init'] if 'ref_init' in kwargs else 0
		self.state = kwargs['state_init'] if 'state_init' in kwargs else 0
		self.timeout = kwargs['timeout'] if 'timeout' in kwargs else 0

		self.error_integral = 0
		self.last_error = 0
		self.tlast = time.time()
		self.available = 1

		# memory of last values for diagnostics

		self.last_dt = 0
		self.last_yp = 0
		self.last_yi = 0
		self.last_yd = 0
		self.last_y = 0
		
	def setRef(self,ref:float):
		self.ref = ref
		
	def setState(self,state:float):
		self.state = state
		
	def reset(self):
		self.tlast = time.time()
		self.error_integral = 0
		self.last_error = 0
		self.available = 1
	
	def calc_error(self):
		return self.ref - self.state

	def compute(self):
		"""
		Compute PID controller output
	
		"""
		if self.available:
			now = time.time()
			if self.timeout:
				if now-self.tlast>self.timeout:
					self.reset()
				
			if self.tlast:
				self.available = 0
				
				dt = now-self.tlast

				error = self.calc_error()
				self.error_integral += error * dt
				
				# Limit integrator buildup
				if self.integral_limits:
					if self.error_integral < self.integral_limits[0]:
						self.error_integral = self.integral_limits[0]
					elif self.error_integral > self.integral_limits[1]:
						self.error_integral = self.integral_limits[1]
				
				if dt>0:
					error_derivative = (error - self.last_error) / dt
				else: 
					error_derivative =0
					print('[WARNING] PIDController somehow tried to differentiate over a timestep of '+str(dt)+'seconds')
				
				yp = self.kp * error
				yi = self.ki * self.error_integral
				yd = self.kd * error_derivative
				out = yp + yi + yd

				# Save last values for diagnostics
				self.last_dt = dt
				self.last_yp = yp
				self.last_yi = yi
				self.last_yd = yd
				self.last_y = out

				# Save last error for derivative calculation next iteration
				self.last_error = error
				
				# Limit output
				if self.output_limits:
					if out < self.output_limits[0]:
						out = self.output_limits[0]
					elif out > self.output_limits[1]:
						out = self.output_limits[1]
				
				self.tlast = now
				self.available = 1
				return out
			else:
				self.tlast = time.time()